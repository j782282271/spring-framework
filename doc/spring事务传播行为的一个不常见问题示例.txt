调用Testmanager1.insert()方法，尽管Testmanager2.insert事会抛出异常，Testmanager2.insert事务回滚，Testmanager1.insert()事务成功
如果将Testmanager2.insert的Propagation.REQUIRES_NEW改为Propagation.REQUIRED，即使Testmanager2.insert的异常被catch住，Testmanager1.insert()事务也会回滚，原因见源码：
AbstractPlatformTransactionManager.processRollback方法中调用的：doSetRollbackOnly(status);
总结见wiki：http://www.mamicode.com/info-detail-1845495.html
@Service
public class Testmanager1 {
    @Autowired
    private Testmanager2 testmanager2;
    @Autowired
    private KongdaoTaskRemarkMapper remarkMapper;

    @Transactional
    public void insert() {
        KongdaoTaskRemark remark = new KongdaoTaskRemark();
        remark.setRemark("fsda");
        remark.setFkCounterId(1);
        remark.setFkMemberId(8899333L);
        remarkMapper.insert(remark);

        try {
            testmanager2.insert();
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println("asfdsfd");
    }
}


@Service
public class Testmanager2 {
    @Transactional(propagation = Propagation.REQUIRES_NEW改为Propagation.REQUIRED，即
    public void insert() {
        throw new RuntimeException("Testmanager2 excweption");
    }
}
